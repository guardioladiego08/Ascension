-- Social foundation for Supabase
-- Safe to run multiple times.

begin;

create schema if not exists social;

-- Public profile stub used by social search/profile lookup.
create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text not null unique,
  display_name text null,
  profile_image_url text null,
  bio text null,
  is_private boolean not null default false,
  profile_row_id uuid null unique,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

alter table public.profiles enable row level security;

drop policy if exists profiles_select_authenticated on public.profiles;
create policy profiles_select_authenticated on public.profiles
for select to authenticated
using (true);

grant select on table public.profiles to authenticated;

-- ---------------------------
-- Core tables
-- ---------------------------

create table if not exists social.follows (
  id bigint generated by default as identity primary key,
  follower_id uuid not null references auth.users(id) on delete cascade,
  followee_id uuid not null references auth.users(id) on delete cascade,
  status text not null default 'pending',
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  accepted_at timestamptz null,
  constraint follows_follower_followee_unique unique (follower_id, followee_id),
  constraint follows_no_self check (follower_id <> followee_id),
  constraint follows_status_check check (status in ('requested', 'pending', 'accepted', 'blocked'))
);

-- Backward compatibility for older schemas that used `following_id`.
do $$
begin
  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'social'
      and table_name = 'follows'
      and column_name = 'following_id'
  )
  and not exists (
    select 1
    from information_schema.columns
    where table_schema = 'social'
      and table_name = 'follows'
      and column_name = 'followee_id'
  ) then
    execute 'alter table social.follows rename column following_id to followee_id';
  end if;
end $$;

alter table social.follows add column if not exists follower_id uuid;
alter table social.follows add column if not exists followee_id uuid;
alter table social.follows add column if not exists status text;
alter table social.follows add column if not exists created_at timestamptz not null default timezone('utc', now());
alter table social.follows add column if not exists updated_at timestamptz not null default timezone('utc', now());
alter table social.follows add column if not exists accepted_at timestamptz null;

alter table social.follows alter column status set default 'pending';

do $$
begin
  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'social'
      and table_name = 'follows'
      and column_name = 'following_id'
  ) then
    execute 'update social.follows set followee_id = following_id where followee_id is null';
  end if;
end $$;

do $$
begin
  -- FK on follower_id
  if not exists (
    select 1 from pg_constraint
    where conname = 'follows_follower_id_fkey'
      and conrelid = 'social.follows'::regclass
  ) then
    alter table social.follows
      add constraint follows_follower_id_fkey
      foreign key (follower_id) references auth.users(id) on delete cascade;
  end if;

  -- FK on followee_id
  if not exists (
    select 1 from pg_constraint
    where conname = 'follows_followee_id_fkey'
      and conrelid = 'social.follows'::regclass
  ) then
    alter table social.follows
      add constraint follows_followee_id_fkey
      foreign key (followee_id) references auth.users(id) on delete cascade;
  end if;
end $$;

-- Normalize legacy rows so unique/index constraints can be applied reliably.
update social.follows
set status = 'pending'
where status is null;

delete from social.follows
where follower_id is null
   or followee_id is null;

with ranked as (
  select
    ctid,
    row_number() over (
      partition by follower_id, followee_id
      order by created_at desc nulls last, ctid desc
    ) as rn
  from social.follows
)
delete from social.follows f
using ranked r
where f.ctid = r.ctid
  and r.rn > 1;

create table if not exists social.blocks (
  id bigint generated by default as identity primary key,
  blocker_id uuid not null references auth.users(id) on delete cascade,
  blocked_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default timezone('utc', now()),
  constraint blocks_unique unique (blocker_id, blocked_id),
  constraint blocks_no_self check (blocker_id <> blocked_id)
);

create table if not exists social.posts (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  source_type text not null default 'manual',
  source_id uuid null,
  session_id uuid null,
  activity_type text not null default 'other',
  title text null,
  subtitle text null,
  caption text null,
  metrics jsonb not null default '{}'::jsonb,
  media_urls text[] not null default '{}',
  visibility text not null default 'followers',
  like_count integer not null default 0,
  comment_count integer not null default 0,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint posts_activity_type_check check (activity_type in ('run', 'walk', 'ride', 'strength', 'nutrition', 'other')),
  constraint posts_visibility_check check (visibility in ('public', 'followers', 'private'))
);

create table if not exists social.media_files (
  id uuid primary key default gen_random_uuid(),
  post_id uuid not null references social.posts(id) on delete cascade,
  media_url text not null,
  media_type text not null,
  thumbnail_url text null,
  sort_order integer not null default 0,
  created_at timestamptz not null default timezone('utc', now()),
  constraint media_files_media_type_check check (media_type in ('image', 'video'))
);

create table if not exists social.post_likes (
  post_id uuid not null references social.posts(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default timezone('utc', now()),
  primary key (post_id, user_id)
);

create table if not exists social.post_comments (
  id uuid primary key default gen_random_uuid(),
  post_id uuid not null references social.posts(id) on delete cascade,
  user_id uuid not null references auth.users(id) on delete cascade,
  parent_comment_id uuid null references social.post_comments(id) on delete cascade,
  body text not null,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  constraint post_comments_body_check check (char_length(trim(body)) > 0)
);

create table if not exists social.notifications (
  id uuid primary key default gen_random_uuid(),
  recipient_id uuid not null references auth.users(id) on delete cascade,
  actor_id uuid null references auth.users(id) on delete set null,
  kind text not null,
  entity_type text null,
  entity_id uuid null,
  message text null,
  is_read boolean not null default false,
  created_at timestamptz not null default timezone('utc', now()),
  read_at timestamptz null,
  constraint notifications_kind_check check (kind in ('follow_request', 'follow_accepted', 'new_follower', 'post_like', 'post_comment', 'new_post'))
);

alter table social.notifications drop constraint if exists notifications_kind_check;
alter table social.notifications
  add constraint notifications_kind_check
  check (kind in ('follow_request', 'follow_accepted', 'new_follower', 'unfollowed', 'post_like', 'post_comment', 'new_post'));

create table if not exists social.user_feed_cache (
  user_id uuid not null references auth.users(id) on delete cascade,
  post_id uuid not null references social.posts(id) on delete cascade,
  score double precision not null default 0,
  inserted_at timestamptz not null default timezone('utc', now()),
  primary key (user_id, post_id)
);

-- ---------------------------
-- Indexes
-- ---------------------------

create unique index if not exists follows_follower_followee_idx
  on social.follows (follower_id, followee_id);

create index if not exists follows_followee_status_created_idx
  on social.follows (followee_id, status, created_at desc);

create index if not exists follows_follower_status_created_idx
  on social.follows (follower_id, status, created_at desc);

create index if not exists blocks_blocked_idx
  on social.blocks (blocked_id);

create index if not exists posts_created_idx
  on social.posts (created_at desc);

create index if not exists posts_user_created_idx
  on social.posts (user_id, created_at desc);

create index if not exists posts_activity_created_idx
  on social.posts (activity_type, created_at desc);

create unique index if not exists posts_unique_source_idx
  on social.posts (user_id, source_type, source_id)
  where source_id is not null;

create index if not exists media_files_post_sort_idx
  on social.media_files (post_id, sort_order asc);

create index if not exists post_likes_user_created_idx
  on social.post_likes (user_id, created_at desc);

create index if not exists post_comments_post_created_idx
  on social.post_comments (post_id, created_at desc);

create index if not exists post_comments_user_created_idx
  on social.post_comments (user_id, created_at desc);

create index if not exists notifications_recipient_read_created_idx
  on social.notifications (recipient_id, is_read, created_at desc);

create index if not exists user_feed_cache_user_score_idx
  on social.user_feed_cache (user_id, score desc, inserted_at desc);

-- ---------------------------
-- Helper functions
-- ---------------------------

create or replace function social.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := timezone('utc', now());
  return new;
end;
$$;

drop trigger if exists profiles_set_updated_at on public.profiles;
create trigger profiles_set_updated_at
before update on public.profiles
for each row execute function social.set_updated_at();

create or replace function social.profile_is_private(p_user_id uuid)
returns boolean
language plpgsql
stable
security definer
set search_path = public, social, "user"
as $$
declare
  v_private boolean;
begin
  begin
    select u.is_private
    into v_private
    from "user".users u
    where u.user_id = p_user_id;
  exception
    when undefined_table then
      v_private := null;
  end;

  if v_private is null then
    begin
      select p.is_private
      into v_private
      from public.profiles p
      where p.id = p_user_id;
    exception
      when undefined_table then
        v_private := null;
    end;
  end if;

  return coalesce(v_private, false);
end;
$$;

create or replace function social.is_blocked(p_left uuid, p_right uuid)
returns boolean
language sql
stable
security definer
set search_path = public, social
as $$
  select exists (
    select 1
    from social.blocks b
    where (b.blocker_id = p_left and b.blocked_id = p_right)
       or (b.blocker_id = p_right and b.blocked_id = p_left)
  );
$$;

create or replace function social.is_following(p_viewer uuid, p_owner uuid)
returns boolean
language sql
stable
security definer
set search_path = public, social
as $$
  select exists (
    select 1
    from social.follows f
    where f.follower_id = p_viewer
      and f.followee_id = p_owner
      and f.status = 'accepted'
  );
$$;

create or replace function social.can_view_post(
  p_viewer uuid,
  p_owner uuid,
  p_visibility text
)
returns boolean
language plpgsql
stable
security definer
set search_path = public, social
as $$
begin
  if p_owner is null then
    return false;
  end if;

  if p_viewer is not null and p_viewer = p_owner then
    return true;
  end if;

  if p_viewer is not null and social.is_blocked(p_viewer, p_owner) then
    return false;
  end if;

  if p_visibility = 'public' then
    return true;
  end if;

  if p_viewer is null then
    return false;
  end if;

  if p_visibility = 'followers' then
    return social.is_following(p_viewer, p_owner);
  end if;

  return false;
end;
$$;

create or replace function social.normalize_follow_row()
returns trigger
language plpgsql
security definer
set search_path = public, social, "user"
as $$
begin
  if new.follower_id = new.followee_id then
    raise exception 'Users cannot follow themselves';
  end if;

  if social.is_blocked(new.follower_id, new.followee_id) then
    raise exception 'Follow blocked between these users';
  end if;

  if new.status not in ('requested', 'pending', 'accepted', 'blocked') then
    raise exception 'Invalid follow status: %', new.status;
  end if;

  if new.status = 'accepted'
     and auth.uid() is not null
     and auth.uid() <> new.followee_id
     and social.profile_is_private(new.followee_id)
  then
    new.status := 'pending';
  end if;

  if new.status = 'accepted' then
    new.accepted_at := coalesce(new.accepted_at, timezone('utc', now()));
  else
    new.accepted_at := null;
  end if;

  return new;
end;
$$;

create or replace function social.apply_like_counter()
returns trigger
language plpgsql
security definer
set search_path = public, social
as $$
begin
  if tg_op = 'INSERT' then
    update social.posts
    set like_count = like_count + 1,
        updated_at = timezone('utc', now())
    where id = new.post_id;
    return new;
  end if;

  update social.posts
  set like_count = greatest(0, like_count - 1),
      updated_at = timezone('utc', now())
  where id = old.post_id;
  return old;
end;
$$;

create or replace function social.apply_comment_counter()
returns trigger
language plpgsql
security definer
set search_path = public, social
as $$
begin
  if tg_op = 'INSERT' then
    update social.posts
    set comment_count = comment_count + 1,
        updated_at = timezone('utc', now())
    where id = new.post_id;
    return new;
  end if;

  update social.posts
  set comment_count = greatest(0, comment_count - 1),
      updated_at = timezone('utc', now())
  where id = old.post_id;
  return old;
end;
$$;

create or replace function social.notify_follow_events()
returns trigger
language plpgsql
security definer
set search_path = public, social
as $$
begin
  if tg_op = 'INSERT' then
    if new.status in ('requested', 'pending') then
      insert into social.notifications (recipient_id, actor_id, kind, entity_type, entity_id, message)
      values (new.followee_id, new.follower_id, 'follow_request', 'follow', null, 'requested to follow you');
    elsif new.status = 'accepted' then
      insert into social.notifications (recipient_id, actor_id, kind, entity_type, entity_id, message)
      values (new.followee_id, new.follower_id, 'new_follower', 'follow', null, 'started following you');
    end if;
    return new;
  end if;

  if tg_op = 'UPDATE'
     and old.status in ('requested', 'pending')
     and new.status = 'accepted'
  then
    insert into social.notifications (recipient_id, actor_id, kind, entity_type, entity_id, message)
    values (new.follower_id, new.followee_id, 'follow_accepted', 'follow', null, 'approved your follow request');
  end if;

  return new;
end;
$$;

create or replace function social.notify_unfollow_event()
returns trigger
language plpgsql
security definer
set search_path = public, social
as $$
begin
  if old.status = 'accepted' then
    insert into social.notifications (recipient_id, actor_id, kind, entity_type, entity_id, message)
    values (old.followee_id, old.follower_id, 'unfollowed', 'follow', null, 'stopped following you');
  end if;
  return old;
end;
$$;

create or replace function social.notify_like_event()
returns trigger
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_owner uuid;
begin
  select p.user_id into v_owner
  from social.posts p
  where p.id = new.post_id;

  if v_owner is not null and v_owner <> new.user_id then
    insert into social.notifications (recipient_id, actor_id, kind, entity_type, entity_id, message)
    values (v_owner, new.user_id, 'post_like', 'post', new.post_id, 'liked your post');
  end if;

  return new;
end;
$$;

create or replace function social.notify_comment_event()
returns trigger
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_owner uuid;
begin
  select p.user_id into v_owner
  from social.posts p
  where p.id = new.post_id;

  if v_owner is not null and v_owner <> new.user_id then
    insert into social.notifications (recipient_id, actor_id, kind, entity_type, entity_id, message)
    values (v_owner, new.user_id, 'post_comment', 'post', new.post_id, 'commented on your post');
  end if;

  return new;
end;
$$;

drop function if exists public.search_profiles(text, integer);
create function public.search_profiles(
  p_query text,
  p_limit integer default 25
)
returns table (
  id uuid,
  user_id uuid,
  username text,
  display_name text,
  profile_image_url text,
  bio text,
  is_private boolean
)
language sql
stable
security definer
set search_path = public, social, "user"
as $$
  select
    u.user_id as id,
    u.user_id as user_id,
    trim(u.username) as username,
    coalesce(
      nullif(trim(coalesce(u.first_name, '') || ' ' || coalesce(u.last_name, '')), ''),
      trim(u.username)
    ) as display_name,
    u.profile_image_url,
    u.bio,
    coalesce(u.is_private, true) as is_private
  from "user".users u
  where trim(coalesce(p_query, '')) <> ''
    and u.username is not null
    and trim(u.username) ilike '%' || trim(p_query) || '%'
  order by trim(u.username) asc
  limit greatest(1, least(coalesce(p_limit, 25), 100));
$$;

drop function if exists public.search_profiles_user(text, integer);
create function public.search_profiles_user(
  p_query text,
  p_limit integer default 25
)
returns table (
  id uuid,
  user_id uuid,
  username text,
  display_name text,
  profile_image_url text,
  bio text,
  is_private boolean
)
language sql
stable
security definer
set search_path = public, social, "user"
as $$
  select
    u.user_id as id,
    u.user_id as user_id,
    trim(u.username) as username,
    coalesce(
      nullif(trim(coalesce(u.first_name, '') || ' ' || coalesce(u.last_name, '')), ''),
      trim(u.username)
    ) as display_name,
    u.profile_image_url,
    u.bio,
    coalesce(u.is_private, true) as is_private
  from "user".users u
  where trim(coalesce(p_query, '')) <> ''
    and u.username is not null
    and trim(u.username) ilike '%' || trim(p_query) || '%'
  order by trim(u.username) asc
  limit greatest(1, least(coalesce(p_limit, 25), 100));
$$;

drop function if exists public.get_profile_card(text);
drop function if exists public.get_profile_card(uuid);
create function public.get_profile_card(
  p_id text
)
returns table (
  id uuid,
  user_id uuid,
  username text,
  display_name text,
  profile_image_url text,
  bio text,
  is_private boolean
)
language sql
stable
security definer
set search_path = public, social, "user"
as $$
  select
    u.user_id as id,
    u.user_id as user_id,
    trim(u.username) as username,
    coalesce(
      nullif(trim(coalesce(u.first_name, '') || ' ' || coalesce(u.last_name, '')), ''),
      trim(u.username)
    ) as display_name,
    u.profile_image_url,
    u.bio,
    coalesce(u.is_private, true) as is_private
  from "user".users u
  where trim(coalesce(p_id, '')) <> ''
    and (
      u.user_id::text = trim(p_id)
      or lower(trim(coalesce(u.username, ''))) = lower(trim(p_id))
    )
  limit 1;
$$;

drop function if exists public.get_profile_card_user(text);
drop function if exists public.get_profile_card_user(uuid);
create function public.get_profile_card_user(
  p_id text
)
returns table (
  id uuid,
  user_id uuid,
  username text,
  display_name text,
  profile_image_url text,
  bio text,
  is_private boolean
)
language sql
stable
security definer
set search_path = public, social, "user"
as $$
  select
    u.user_id as id,
    u.user_id as user_id,
    trim(u.username) as username,
    coalesce(
      nullif(trim(coalesce(u.first_name, '') || ' ' || coalesce(u.last_name, '')), ''),
      trim(u.username)
    ) as display_name,
    u.profile_image_url,
    u.bio,
    coalesce(u.is_private, true) as is_private
  from "user".users u
  where trim(coalesce(p_id, '')) <> ''
    and (
      u.user_id::text = trim(p_id)
      or lower(trim(coalesce(u.username, ''))) = lower(trim(p_id))
    )
  limit 1;
$$;

drop function if exists public.get_follow_status_user(uuid);
create function public.get_follow_status_user(
  p_target_id uuid
)
returns text
language sql
stable
security definer
set search_path = public, social
as $$
  select coalesce(
    (
      select
        case
          when f.status = 'accepted' then 'accepted'
          when f.status in ('requested', 'pending') then 'requested'
          else 'none'
        end
      from social.follows f
      where f.follower_id = auth.uid()
        and f.followee_id = p_target_id
      limit 1
    ),
    'none'
  );
$$;

drop function if exists public.follow_user(uuid);
create function public.follow_user(
  p_followee_id uuid
)
returns text
language plpgsql
security definer
set search_path = public, social, "user"
as $$
declare
  v_me uuid := auth.uid();
  v_is_private boolean;
  v_status text;
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  if p_followee_id is null then
    raise exception 'Target user id is required';
  end if;

  if v_me = p_followee_id then
    raise exception 'Users cannot follow themselves';
  end if;

  if social.is_blocked(v_me, p_followee_id) then
    raise exception 'Follow blocked between these users';
  end if;

  if exists (
    select 1
    from social.follows f
    where f.follower_id = v_me
      and f.followee_id = p_followee_id
      and f.status = 'blocked'
  ) then
    raise exception 'Follow blocked between these users';
  end if;

  v_is_private := social.profile_is_private(p_followee_id);
  v_status := case when v_is_private then 'pending' else 'accepted' end;

  insert into social.follows (follower_id, followee_id, status, accepted_at)
  values (
    v_me,
    p_followee_id,
    v_status,
    case when v_status = 'accepted' then timezone('utc', now()) else null end
  )
  on conflict (follower_id, followee_id)
  do update
  set status = excluded.status,
      accepted_at = case
        when excluded.status = 'accepted' then coalesce(social.follows.accepted_at, timezone('utc', now()))
        else null
      end,
      updated_at = timezone('utc', now());

  return v_status;
end;
$$;

drop function if exists public.unfollow_user(uuid);
create function public.unfollow_user(
  p_followee_id uuid
)
returns boolean
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_me uuid := auth.uid();
  v_deleted boolean := false;
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  if p_followee_id is null then
    return false;
  end if;

  delete from social.follows
  where follower_id = v_me
    and followee_id = p_followee_id
  returning true into v_deleted;

  return coalesce(v_deleted, false);
end;
$$;

drop function if exists public.list_inbound_follow_requests_user(integer, integer);
create function public.list_inbound_follow_requests_user(
  p_limit integer default 100,
  p_offset integer default 0
)
returns table (
  follower_id uuid,
  created_at timestamptz
)
language sql
stable
security definer
set search_path = public, social
as $$
  select
    f.follower_id,
    f.created_at
  from social.follows f
  where f.followee_id = auth.uid()
    and f.status in ('requested', 'pending')
  order by f.created_at desc
  limit greatest(1, least(coalesce(p_limit, 100), 200))
  offset greatest(coalesce(p_offset, 0), 0);
$$;

drop function if exists public.accept_follow_request_user(uuid);
create function public.accept_follow_request_user(
  p_follower_id uuid
)
returns boolean
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_me uuid := auth.uid();
  v_updated boolean := false;
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  update social.follows
  set status = 'accepted',
      accepted_at = coalesce(accepted_at, timezone('utc', now())),
      updated_at = timezone('utc', now())
  where followee_id = v_me
    and follower_id = p_follower_id
    and status in ('requested', 'pending')
  returning true into v_updated;

  return coalesce(v_updated, false);
end;
$$;

drop function if exists public.decline_follow_request_user(uuid);
create function public.decline_follow_request_user(
  p_follower_id uuid
)
returns boolean
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_me uuid := auth.uid();
  v_deleted boolean := false;
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  delete from social.follows
  where followee_id = v_me
    and follower_id = p_follower_id
    and status in ('requested', 'pending')
  returning true into v_deleted;

  return coalesce(v_deleted, false);
end;
$$;

drop function if exists public.list_followers_user(uuid, integer, integer);
create function public.list_followers_user(
  p_user_id uuid,
  p_limit integer default 100,
  p_offset integer default 0
)
returns table (
  id uuid,
  user_id uuid,
  username text,
  display_name text,
  profile_image_url text,
  bio text,
  is_private boolean,
  followed_at timestamptz
)
language sql
stable
security definer
set search_path = public, social, "user"
as $$
  select
    u.user_id as id,
    u.user_id as user_id,
    trim(u.username) as username,
    coalesce(
      nullif(trim(coalesce(u.first_name, '') || ' ' || coalesce(u.last_name, '')), ''),
      trim(u.username)
    ) as display_name,
    u.profile_image_url,
    u.bio,
    coalesce(u.is_private, true) as is_private,
    f.created_at as followed_at
  from social.follows f
  join "user".users u on u.user_id = f.follower_id
  where f.followee_id = p_user_id
    and f.status = 'accepted'
    and u.username is not null
  order by f.created_at desc
  limit greatest(1, least(coalesce(p_limit, 100), 200))
  offset greatest(coalesce(p_offset, 0), 0);
$$;

drop function if exists public.list_following_user(uuid, integer, integer);
create function public.list_following_user(
  p_user_id uuid,
  p_limit integer default 100,
  p_offset integer default 0
)
returns table (
  id uuid,
  user_id uuid,
  username text,
  display_name text,
  profile_image_url text,
  bio text,
  is_private boolean,
  followed_at timestamptz
)
language sql
stable
security definer
set search_path = public, social, "user"
as $$
  select
    u.user_id as id,
    u.user_id as user_id,
    trim(u.username) as username,
    coalesce(
      nullif(trim(coalesce(u.first_name, '') || ' ' || coalesce(u.last_name, '')), ''),
      trim(u.username)
    ) as display_name,
    u.profile_image_url,
    u.bio,
    coalesce(u.is_private, true) as is_private,
    f.created_at as followed_at
  from social.follows f
  join "user".users u on u.user_id = f.followee_id
  where f.follower_id = p_user_id
    and f.status = 'accepted'
    and u.username is not null
  order by f.created_at desc
  limit greatest(1, least(coalesce(p_limit, 100), 200))
  offset greatest(coalesce(p_offset, 0), 0);
$$;

drop function if exists public.list_outbound_follow_requests_user(integer, integer);
create function public.list_outbound_follow_requests_user(
  p_limit integer default 100,
  p_offset integer default 0
)
returns table (
  followee_id uuid,
  created_at timestamptz
)
language sql
stable
security definer
set search_path = public, social
as $$
  select
    f.followee_id,
    f.created_at
  from social.follows f
  where f.follower_id = auth.uid()
    and f.status in ('requested', 'pending')
  order by f.created_at desc
  limit greatest(1, least(coalesce(p_limit, 100), 200))
  offset greatest(coalesce(p_offset, 0), 0);
$$;

drop function if exists public.list_accepted_following_ids_user(integer, integer);
create function public.list_accepted_following_ids_user(
  p_limit integer default 100,
  p_offset integer default 0
)
returns table (
  followee_id uuid,
  created_at timestamptz
)
language sql
stable
security definer
set search_path = public, social
as $$
  select
    f.followee_id,
    f.created_at
  from social.follows f
  where f.follower_id = auth.uid()
    and f.status = 'accepted'
  order by f.created_at desc
  limit greatest(1, least(coalesce(p_limit, 100), 200))
  offset greatest(coalesce(p_offset, 0), 0);
$$;

drop function if exists public.list_notifications_user(integer, integer);
create function public.list_notifications_user(
  p_limit integer default 100,
  p_offset integer default 0
)
returns table (
  id uuid,
  actor_id uuid,
  kind text,
  message text,
  is_read boolean,
  created_at timestamptz
)
language sql
stable
security definer
set search_path = public, social
as $$
  select
    n.id,
    n.actor_id,
    n.kind,
    n.message,
    n.is_read,
    n.created_at
  from social.notifications n
  where n.recipient_id = auth.uid()
  order by n.created_at desc
  limit greatest(1, least(coalesce(p_limit, 100), 200))
  offset greatest(coalesce(p_offset, 0), 0);
$$;

drop function if exists public.mark_follow_request_notifications_read_user(uuid);
create function public.mark_follow_request_notifications_read_user(
  p_actor_id uuid
)
returns integer
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_me uuid := auth.uid();
  v_updated integer := 0;
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  update social.notifications
  set is_read = true,
      read_at = coalesce(read_at, timezone('utc', now()))
  where recipient_id = v_me
    and actor_id = p_actor_id
    and kind = 'follow_request'
    and is_read = false;

  get diagnostics v_updated = row_count;
  return v_updated;
end;
$$;

drop function if exists public.get_profile_stats_user(uuid);
create function public.get_profile_stats_user(
  p_user_id uuid
)
returns table (
  posts bigint,
  followers bigint,
  following bigint
)
language sql
stable
security definer
set search_path = public, social
as $$
  select
    (select count(*) from social.posts p where p.user_id = p_user_id) as posts,
    (
      select count(*)
      from social.follows f
      where f.followee_id = p_user_id
        and f.status = 'accepted'
    ) as followers,
    (
      select count(*)
      from social.follows f
      where f.follower_id = p_user_id
        and f.status = 'accepted'
    ) as following;
$$;

drop function if exists public.get_feed_user(integer, integer, text);
create function public.get_feed_user(
  p_limit integer default 20,
  p_offset integer default 0,
  p_activity_type text default null
)
returns table (
  id uuid,
  user_id uuid,
  activity_type text,
  title text,
  subtitle text,
  caption text,
  metrics jsonb,
  visibility text,
  created_at timestamptz,
  like_count integer,
  comment_count integer
)
language sql
stable
security definer
set search_path = public, social
as $$
  with me as (
    select auth.uid() as uid
  ),
  author_set as (
    select uid as user_id
    from me
    where uid is not null
    union
    select f.followee_id as user_id
    from social.follows f
    join me on me.uid = f.follower_id
    where f.status = 'accepted'
  )
  select
    p.id,
    p.user_id,
    p.activity_type,
    p.title,
    p.subtitle,
    p.caption,
    p.metrics,
    p.visibility,
    p.created_at,
    p.like_count,
    p.comment_count
  from social.posts p
  join author_set a on a.user_id = p.user_id
  where (p_activity_type is null or p.activity_type = p_activity_type)
    and social.can_view_post((select uid from me), p.user_id, p.visibility)
  order by p.created_at desc
  limit greatest(coalesce(p_limit, 20), 1)
  offset greatest(coalesce(p_offset, 0), 0);
$$;

drop function if exists public.get_liked_post_ids_user(uuid[]);
create function public.get_liked_post_ids_user(
  p_post_ids uuid[]
)
returns table (
  post_id uuid
)
language sql
stable
security definer
set search_path = public, social
as $$
  select pl.post_id
  from social.post_likes pl
  where pl.user_id = auth.uid()
    and pl.post_id = any(coalesce(p_post_ids, '{}'::uuid[]));
$$;

drop function if exists public.like_post_user(uuid);
create function public.like_post_user(
  p_post_id uuid
)
returns boolean
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_me uuid := auth.uid();
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  if p_post_id is null then
    return false;
  end if;

  insert into social.post_likes (post_id, user_id)
  values (p_post_id, v_me)
  on conflict (post_id, user_id) do nothing;

  return true;
end;
$$;

drop function if exists public.unlike_post_user(uuid);
create function public.unlike_post_user(
  p_post_id uuid
)
returns boolean
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_me uuid := auth.uid();
  v_deleted boolean := false;
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  if p_post_id is null then
    return false;
  end if;

  delete from social.post_likes
  where post_id = p_post_id
    and user_id = v_me
  returning true into v_deleted;

  return coalesce(v_deleted, false);
end;
$$;

drop function if exists public.share_run_walk_session_user(uuid, text, text, text, text, text, jsonb);
create function public.share_run_walk_session_user(
  p_session_id uuid,
  p_activity_type text,
  p_title text,
  p_subtitle text,
  p_caption text,
  p_visibility text,
  p_metrics jsonb
)
returns uuid
language plpgsql
security definer
set search_path = public, social
as $$
declare
  v_me uuid := auth.uid();
  v_post_id uuid;
begin
  if v_me is null then
    raise exception 'Not authenticated';
  end if;

  insert into social.posts (
    user_id,
    source_type,
    source_id,
    session_id,
    activity_type,
    title,
    subtitle,
    caption,
    metrics,
    visibility
  )
  values (
    v_me,
    'run_walk_session',
    p_session_id,
    p_session_id,
    coalesce(nullif(trim(p_activity_type), ''), 'run'),
    nullif(trim(coalesce(p_title, '')), ''),
    nullif(trim(coalesce(p_subtitle, '')), ''),
    nullif(trim(coalesce(p_caption, '')), ''),
    coalesce(p_metrics, '{}'::jsonb),
    coalesce(nullif(trim(p_visibility), ''), 'followers')
  )
  on conflict (user_id, source_type, source_id)
  do update
  set session_id = excluded.session_id,
      activity_type = excluded.activity_type,
      title = excluded.title,
      subtitle = excluded.subtitle,
      caption = excluded.caption,
      metrics = excluded.metrics,
      visibility = excluded.visibility,
      updated_at = timezone('utc', now())
  returning id into v_post_id;

  return v_post_id;
end;
$$;

grant execute on function public.search_profiles(text, integer) to authenticated;
grant execute on function public.search_profiles_user(text, integer) to authenticated;
grant execute on function public.get_profile_card(text) to authenticated;
grant execute on function public.get_profile_card_user(text) to authenticated;
grant execute on function public.get_follow_status_user(uuid) to authenticated;
grant execute on function public.follow_user(uuid) to authenticated;
grant execute on function public.unfollow_user(uuid) to authenticated;
grant execute on function public.list_inbound_follow_requests_user(integer, integer) to authenticated;
grant execute on function public.accept_follow_request_user(uuid) to authenticated;
grant execute on function public.decline_follow_request_user(uuid) to authenticated;
grant execute on function public.list_followers_user(uuid, integer, integer) to authenticated;
grant execute on function public.list_following_user(uuid, integer, integer) to authenticated;
grant execute on function public.list_outbound_follow_requests_user(integer, integer) to authenticated;
grant execute on function public.list_accepted_following_ids_user(integer, integer) to authenticated;
grant execute on function public.list_notifications_user(integer, integer) to authenticated;
grant execute on function public.mark_follow_request_notifications_read_user(uuid) to authenticated;
grant execute on function public.get_profile_stats_user(uuid) to authenticated;
grant execute on function public.get_feed_user(integer, integer, text) to authenticated;
grant execute on function public.get_liked_post_ids_user(uuid[]) to authenticated;
grant execute on function public.like_post_user(uuid) to authenticated;
grant execute on function public.unlike_post_user(uuid) to authenticated;
grant execute on function public.share_run_walk_session_user(uuid, text, text, text, text, text, jsonb) to authenticated;

create or replace function social.get_profile_stats(p_user_id uuid)
returns table (
  posts bigint,
  followers bigint,
  following bigint
)
language sql
stable
security definer
set search_path = public, social
as $$
  select
    (select count(*) from social.posts p where p.user_id = p_user_id) as posts,
    (
      select count(*)
      from social.follows f
      where f.followee_id = p_user_id
        and f.status = 'accepted'
    ) as followers,
    (
      select count(*)
      from social.follows f
      where f.follower_id = p_user_id
        and f.status = 'accepted'
    ) as following;
$$;

create or replace function social.get_feed(
  p_limit integer default 20,
  p_offset integer default 0,
  p_activity_type text default null
)
returns table (
  id uuid,
  user_id uuid,
  activity_type text,
  title text,
  subtitle text,
  caption text,
  metrics jsonb,
  visibility text,
  created_at timestamptz,
  like_count integer,
  comment_count integer
)
language sql
stable
security definer
set search_path = public, social
as $$
  with me as (
    select auth.uid() as uid
  ),
  author_set as (
    select uid as user_id
    from me
    where uid is not null
    union
    select f.followee_id as user_id
    from social.follows f
    join me on me.uid = f.follower_id
    where f.status = 'accepted'
  )
  select
    p.id,
    p.user_id,
    p.activity_type,
    p.title,
    p.subtitle,
    p.caption,
    p.metrics,
    p.visibility,
    p.created_at,
    p.like_count,
    p.comment_count
  from social.posts p
  join author_set a on a.user_id = p.user_id
  where (p_activity_type is null or p.activity_type = p_activity_type)
    and social.can_view_post((select uid from me), p.user_id, p.visibility)
  order by p.created_at desc
  limit greatest(coalesce(p_limit, 20), 1)
  offset greatest(coalesce(p_offset, 0), 0);
$$;

-- ---------------------------
-- Triggers
-- ---------------------------

drop trigger if exists follows_set_updated_at on social.follows;
create trigger follows_set_updated_at
before update on social.follows
for each row execute function social.set_updated_at();

drop trigger if exists follows_normalize_before_write on social.follows;
create trigger follows_normalize_before_write
before insert or update on social.follows
for each row execute function social.normalize_follow_row();

drop trigger if exists posts_set_updated_at on social.posts;
create trigger posts_set_updated_at
before update on social.posts
for each row execute function social.set_updated_at();

drop trigger if exists post_comments_set_updated_at on social.post_comments;
create trigger post_comments_set_updated_at
before update on social.post_comments
for each row execute function social.set_updated_at();

drop trigger if exists post_likes_counter on social.post_likes;
create trigger post_likes_counter
after insert or delete on social.post_likes
for each row execute function social.apply_like_counter();

drop trigger if exists post_comments_counter on social.post_comments;
create trigger post_comments_counter
after insert or delete on social.post_comments
for each row execute function social.apply_comment_counter();

drop trigger if exists follows_notifications_insert on social.follows;
create trigger follows_notifications_insert
after insert on social.follows
for each row execute function social.notify_follow_events();

drop trigger if exists follows_notifications_update on social.follows;
create trigger follows_notifications_update
after update on social.follows
for each row execute function social.notify_follow_events();

drop trigger if exists follows_notifications_delete on social.follows;
create trigger follows_notifications_delete
after delete on social.follows
for each row execute function social.notify_unfollow_event();

drop trigger if exists post_likes_notifications_insert on social.post_likes;
create trigger post_likes_notifications_insert
after insert on social.post_likes
for each row execute function social.notify_like_event();

drop trigger if exists post_comments_notifications_insert on social.post_comments;
create trigger post_comments_notifications_insert
after insert on social.post_comments
for each row execute function social.notify_comment_event();

-- ---------------------------
-- Grants
-- ---------------------------

grant usage on schema social to authenticated;
grant select, insert, update, delete on all tables in schema social to authenticated;
grant usage, select on all sequences in schema social to authenticated;
grant execute on function social.get_profile_stats(uuid) to authenticated;
grant execute on function social.get_feed(integer, integer, text) to authenticated;

-- ---------------------------
-- RLS
-- ---------------------------

alter table social.follows enable row level security;
alter table social.blocks enable row level security;
alter table social.posts enable row level security;
alter table social.media_files enable row level security;
alter table social.post_likes enable row level security;
alter table social.post_comments enable row level security;
alter table social.notifications enable row level security;
alter table social.user_feed_cache enable row level security;

-- follows

drop policy if exists follows_select on social.follows;
create policy follows_select on social.follows
for select to authenticated
using (
  auth.uid() = follower_id
  or auth.uid() = followee_id
  or status = 'accepted'
);

drop policy if exists follows_insert on social.follows;
create policy follows_insert on social.follows
for insert to authenticated
with check (
  auth.uid() = follower_id
  and status in ('requested', 'accepted', 'pending')
);

drop policy if exists follows_update on social.follows;
create policy follows_update on social.follows
for update to authenticated
using (auth.uid() = follower_id or auth.uid() = followee_id)
with check (auth.uid() = follower_id or auth.uid() = followee_id);

drop policy if exists follows_delete on social.follows;
create policy follows_delete on social.follows
for delete to authenticated
using (auth.uid() = follower_id or auth.uid() = followee_id);

-- blocks

drop policy if exists blocks_select on social.blocks;
create policy blocks_select on social.blocks
for select to authenticated
using (auth.uid() = blocker_id or auth.uid() = blocked_id);

drop policy if exists blocks_insert on social.blocks;
create policy blocks_insert on social.blocks
for insert to authenticated
with check (auth.uid() = blocker_id);

drop policy if exists blocks_delete on social.blocks;
create policy blocks_delete on social.blocks
for delete to authenticated
using (auth.uid() = blocker_id);

-- posts

drop policy if exists posts_select on social.posts;
create policy posts_select on social.posts
for select to authenticated
using (social.can_view_post(auth.uid(), user_id, visibility));

drop policy if exists posts_insert on social.posts;
create policy posts_insert on social.posts
for insert to authenticated
with check (auth.uid() = user_id);

drop policy if exists posts_update on social.posts;
create policy posts_update on social.posts
for update to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

drop policy if exists posts_delete on social.posts;
create policy posts_delete on social.posts
for delete to authenticated
using (auth.uid() = user_id);

-- media_files

drop policy if exists media_files_select on social.media_files;
create policy media_files_select on social.media_files
for select to authenticated
using (
  exists (
    select 1
    from social.posts p
    where p.id = media_files.post_id
      and social.can_view_post(auth.uid(), p.user_id, p.visibility)
  )
);

drop policy if exists media_files_insert on social.media_files;
create policy media_files_insert on social.media_files
for insert to authenticated
with check (
  exists (
    select 1
    from social.posts p
    where p.id = media_files.post_id
      and p.user_id = auth.uid()
  )
);

drop policy if exists media_files_update on social.media_files;
create policy media_files_update on social.media_files
for update to authenticated
using (
  exists (
    select 1
    from social.posts p
    where p.id = media_files.post_id
      and p.user_id = auth.uid()
  )
)
with check (
  exists (
    select 1
    from social.posts p
    where p.id = media_files.post_id
      and p.user_id = auth.uid()
  )
);

drop policy if exists media_files_delete on social.media_files;
create policy media_files_delete on social.media_files
for delete to authenticated
using (
  exists (
    select 1
    from social.posts p
    where p.id = media_files.post_id
      and p.user_id = auth.uid()
  )
);

-- post_likes

drop policy if exists post_likes_select on social.post_likes;
create policy post_likes_select on social.post_likes
for select to authenticated
using (
  exists (
    select 1
    from social.posts p
    where p.id = post_likes.post_id
      and social.can_view_post(auth.uid(), p.user_id, p.visibility)
  )
);

drop policy if exists post_likes_insert on social.post_likes;
create policy post_likes_insert on social.post_likes
for insert to authenticated
with check (
  auth.uid() = user_id
  and exists (
    select 1
    from social.posts p
    where p.id = post_likes.post_id
      and social.can_view_post(auth.uid(), p.user_id, p.visibility)
  )
);

drop policy if exists post_likes_delete on social.post_likes;
create policy post_likes_delete on social.post_likes
for delete to authenticated
using (auth.uid() = user_id);

-- post_comments

drop policy if exists post_comments_select on social.post_comments;
create policy post_comments_select on social.post_comments
for select to authenticated
using (
  exists (
    select 1
    from social.posts p
    where p.id = post_comments.post_id
      and social.can_view_post(auth.uid(), p.user_id, p.visibility)
  )
);

drop policy if exists post_comments_insert on social.post_comments;
create policy post_comments_insert on social.post_comments
for insert to authenticated
with check (
  auth.uid() = user_id
  and char_length(trim(body)) > 0
  and exists (
    select 1
    from social.posts p
    where p.id = post_comments.post_id
      and social.can_view_post(auth.uid(), p.user_id, p.visibility)
  )
);

drop policy if exists post_comments_update on social.post_comments;
create policy post_comments_update on social.post_comments
for update to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id and char_length(trim(body)) > 0);

drop policy if exists post_comments_delete on social.post_comments;
create policy post_comments_delete on social.post_comments
for delete to authenticated
using (auth.uid() = user_id);

-- notifications

drop policy if exists notifications_select on social.notifications;
create policy notifications_select on social.notifications
for select to authenticated
using (auth.uid() = recipient_id);

drop policy if exists notifications_insert on social.notifications;
create policy notifications_insert on social.notifications
for insert to authenticated
with check (
  auth.uid() = actor_id
  or auth.role() = 'service_role'
);

drop policy if exists notifications_update on social.notifications;
create policy notifications_update on social.notifications
for update to authenticated
using (auth.uid() = recipient_id)
with check (auth.uid() = recipient_id);

drop policy if exists notifications_delete on social.notifications;
create policy notifications_delete on social.notifications
for delete to authenticated
using (auth.uid() = recipient_id);

-- user_feed_cache

drop policy if exists user_feed_cache_select on social.user_feed_cache;
create policy user_feed_cache_select on social.user_feed_cache
for select to authenticated
using (auth.uid() = user_id);

drop policy if exists user_feed_cache_insert on social.user_feed_cache;
create policy user_feed_cache_insert on social.user_feed_cache
for insert to authenticated
with check (auth.uid() = user_id or auth.role() = 'service_role');

drop policy if exists user_feed_cache_update on social.user_feed_cache;
create policy user_feed_cache_update on social.user_feed_cache
for update to authenticated
using (auth.uid() = user_id or auth.role() = 'service_role')
with check (auth.uid() = user_id or auth.role() = 'service_role');

drop policy if exists user_feed_cache_delete on social.user_feed_cache;
create policy user_feed_cache_delete on social.user_feed_cache
for delete to authenticated
using (auth.uid() = user_id or auth.role() = 'service_role');

-- Ensure PostgREST sees newly created tables/functions immediately.
notify pgrst, 'reload schema';

commit;
